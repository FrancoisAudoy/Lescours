const nbFloors = 4;

node Button
     state light : bool : public;
     init light := false;
     event push : public; off;
     trans true |- push -> light := true; // appui utilisateur
     	   true |- off -> light := false; // signal
edon

node Door
     state closed : bool : public;
     init closed := true;
     event close, open;
     trans
           true |- close -> closed := true; // signal reçu
           true |- open -> closed := false; // signal reçu
edon

// Petite modif : le bouton s'éteint en fermant la porte
// (ainsi l'utilisateur peut s'acharner sur le bouton)

node Floor
     sub
	B : Button;
	D : Door;
     event
	close, open;
     trans
	not D.closed |- close -> ;
	D.closed |- open -> ;
     sync
	<close, D.close, B.off>;
	<open, D.open>;
edon

node Lift
     sub
	B : Button[nbFloors];
	D : Door;
     state
	level : [0, nbFloors-1] : public;
     init
	level := 0;
     event
	close[nbFloors], open;
	down, up;
     trans
	not D.closed & level=0 |- close[0] -> ;
	not D.closed & level=1 |- close[1] -> ;
	not D.closed & level=2 |- close[2] -> ;
	not D.closed & level=3 |- close[3] -> ;
	D.closed |- open -> ;
	D.closed |- down -> level := level - 1 ;
	D.closed |- up -> level := level + 1 ;
     sync
	<close[0], D.close, B[0].off>;
	<close[1], D.close, B[1].off>;
	<close[2], D.close, B[2].off>;
	<close[3], D.close, B[3].off>;
	<open, D.open>;
edon

node Building
     sub
	F : Floor[nbFloors];
	L : Lift;
     event
	open[nbFloors];
	down, up;
     flow
	request : bool[nbFloors] : private;
	requestDown, requestUp : bool : private;
     assert
	request[0] = (F[0].B.light | L.B[0].light);
	request[1] = (F[1].B.light | L.B[1].light);
	request[2] = (F[2].B.light | L.B[2].light);
	request[3] = (F[3].B.light | L.B[3].light);
	requestDown = ((request[0] & L.level > 0)|
		        (request[1] & L.level > 1)|
			(request[2] & L.level > 2));
	requestUp = ((request[3] & L.level < 3)|
		      (request[2] & L.level < 2)|
		      (request[1] & L.level < 1));
     trans
	L.level=0 & (F[0].B.light | L.B[0].light) |- open[0] -> ;
	L.level=1 & (F[1].B.light | L.B[1].light) |- open[1] -> ;
	L.level=2 & (F[2].B.light | L.B[2].light) |- open[2] -> ;
	L.level=3 & (F[3].B.light | L.B[3].light) |- open[3] -> ;
	requestDown |- down -> ;
	requestUp   |- up   -> ;
     sync
	<F[0].close, L.close[0]>;
	<F[1].close, L.close[1]>;
	<F[2].close, L.close[2]>;
	<F[3].close, L.close[3]>;
	<open[0], F[0].open, L.open>;
	<open[1], F[1].open, L.open>;
	<open[2], F[2].open, L.open>;
	<open[3], F[3].open, L.open>;
	<down, L.down>;
	<up, L.up>;
edon


